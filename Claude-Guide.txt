*****************************
Bend Language Reference Guide
*****************************

1. Introduction to Bend:
Bend is a high-level, massively parallel programming language that feels like Python but scales like CUDA. It runs on both CPUs and GPUs, automatically parallelizing code that isn't "helplessly sequential". Bend is designed for writing parallel algorithms in a functional style, leveraging immutable data structures and recursive patterns.

Key features:
- Automatic parallelization
- Functional programming paradigm
- Immutable by default
- Pattern matching and recursive data structures
- Runs on both CPUs and GPUs

Current limitations:
- 24-bit number size (u24, i24, f24)
- 4GB memory limit
- Limited I/O capabilities (in development)

2. Basic Syntax and Language Structure:
<Content from syntax.md>
# Imp Syntax

## Top-level definitions

### Def

Defines a top level function.

```python
def add(x, y):
  result = x + y
  return result

def main:
  return add(40, 2)
```

A function definition is composed by a name, a sequence of parameters and a body.

A top-level name can be anything matching the regex `[A-Za-z0-9_.-/]+`, except it can't have `__` (used for generated names) or start with `//`.

The last statement of each function must either be a `return` or a selection statement (`if`, `switch`, `match`, `fold`)
where all branches `return`.

### Type

Defines an algebraic data type.

```python
type Option:
  Some { value }
  None

type Tree:
  Node { value, ~left, ~right }
  Leaf
```

Type names must be unique, and should have at least one constructor.

Each constructor is defined by a name followed by its fields.

The `~` notation indicates a recursive field. To use `fold` statements with a type its recursive fields must be correctly marked with `~`.

The constructor names inherit the name of their types and become functions (`Tree/Node` and `Tree/Leaf` in this case).
The exact function they become depends on the encoding.

Read [defining data types](./defining-data-types.md) to know more.

### Object

Defines a type with a single constructor (like a struct, a record or a class).

```python
object Pair { fst, snd }

object Function { name, args, body }

object Vec { len, data }
```

The constructor created from this definition has the same name as the type.

Since it only has one constructor, `fold`ing a recursive `object` requires some additional stop condition apart from pattern matching on the value itself (like an `if` statement).

## Statements

### Assignment

```python
value = 2
return value

(first, second) = (1, 2)
return second

{x y} = {2 3}
```

Assigns a value to a variable.

It's possible to assign to a pattern, like a tuple or superposition, which will destructure the value returned by the expression.

```python
(first, second) = (1, 2)

first, second = 1, 2
```

### Use

```rust
use x = 2 + 3
return x + x
```

Inline copies of the declared bind, it is equivalent to this code:

```rust
return ((2 + 3) + (2 + 3))
```

### In-Place Operation

```python
x += 1
return x
```

The in-place operation does an infix operation and re-assigns a variable.

The operations are:

- Addition `+=`
- Subtraction `-=`
- Multiplication `*=`
- Division `/=`
- Bit And `&=`
- Bit Or `|=`
- Bit Xor `^=`
- Mapper `@=`

The mapper in-place operation applies a function and re-assigns the variable:

```python
x = "hello"
x @= String/uppercase
```

### Return

```python
return "hello"
```

Returns the expression that follows. The last statement of each branch of a function must be a `return`.

```py
# Allowed, all branches return
def max(a, b):
  if a > b:
    return a
  else:
    return b
```

```py
# Not allowed, early return
def Foo(x):
  if test_condition(x):
    return "err"
  else:
    y = map(x)

  return y
```

```py
# Not allowed, one of the branches doesn't return
def Foo(a, b):
  if a < b:
    return a
  else:
    c = a + b
```

### If

```python
if condition:
  return 0
else:
  return 1
```

A branching statement where `else` is mandatory.

The condition must return a `u24` number, where 0 will run the `else` branch and any other value will return the first one.

It is possible to make if-chains using `elif`:

```python
if condition1:
  return 0
elif condition2:
  return 1
elif condition3:
  return 2
else:
  return 3
```

The conditions are evaluated in order, one by one, stopping at the first successful case.

### Switch

```python
switch x = 5:
  case 0:
    return 6
  case 1:
    return 7
  case _:
    return x-2
```

A switch binds a variable name to the result of a given condition and branches to the case matching its value. Cases
must be listed from least to greatest, beginning with `0` and incrementing by 1. The last case must be `_`, which
catches all values not explicitly enumerated. Switches may only be used with native numbers values.

In the last case, the predecessor value is available with the name `bound_var-next_num`, where `bound_var` is the variable
set by the condition and `next_num` is the expected value of the next case. For example, the above example code returns
`3`, since `x-2` is bound to `5 - 2` and the value of `x` doesn't match any explicit case.

This switch statement is equivalent to the `if` from the previous section:

```python
switch _ = condition:
  case 0:
    # else branch
    return 1
  case _:
    # then branch
    return 0
```

### Match

```python
match x = Option/none:
  case Option/some:
    y = x.value
  case Option/none:
    y = 0
```

A pattern matching statement, the cases must be the constructor names of the matching value.

It is possible to bind a variable name to the matching value. The fields of the matched constructor are bound to `matched_var.field_name`.

### Fold

```python
fold x = Tree/leaf:
  case Tree/node:
    return x.value + x.left + x.right
  case Tree/leaf:
    return 0
```

A fold statement. Reduces the given value with the given match cases.

It is possible to bind a variable name to the matching value. Just like in `match`, the fields are bound to `matched_var.field_name`.

For fields notated with `~` in the type definition, the fold function is called implicitly.

It is equivalent to the inline recursive function:

```python
def fold(x):
  match x:
    case Tree/Node:
      return x.value + fold(x.left) + fold(x.right)
    case Tree/Leaf:
      return 0
...
fold(Tree/Leaf)
```

### Bend

Bend can be used to create recursive data structures:

```rust
bend x = 0:
  when x < 10:
    left = fork(x + 1)
    right = fork(x + 1)
    y = Tree/Node(left, right)
  else:
    y = Tree/Leaf(x)
```

Which binds a variable to the return of an inline recursive function.
The function `fork` is available inside the `when` arm of the `bend` and calls it recursively.

It is possible to pass multiple state variables, which can be initialized:

```python
bend x = 1, y = 2 ...:
  when condition(x, y, ...):
    ...
```

When calling `fork`, the function must receive the same number of arguments as the number of state variables.

It is equivalent to this inline recursive function:

```python
def bend(x, y, ...):
  if condition(x, y, ...):
    ...
    return ... bend(x, y, ...) ...
  else:
    return ...
```

### Open

```python
p = Point { x: 1, y: 2 }
open Point: p
return Point { x: p.x * p.x, y: p.y * p.y }
```

Brings the inner fields of an object into scope. The original variable can still be accessed, but doing so will cause any used fields to be duplicated.

It's equivalent to pattern matching on the object, with the restriction that its type must have only one constructor.

```python
open Point: p
...

# Equivalent to:
match p:
  Point:
    ...
```

### With block

```python
with Result:
  x <- safe_div(2, 0)
  return x
```

A monadic `with` block.

Where `x <- ...` performs a monadic operation.

Expects `Result` to be a type defined with `type` or `object` and the function `Result/bind` to be defined.
The monadic bind function should be of type `(Result a) -> (a -> Result b) -> Result b`, like this:

```python
def Result/bind(res, nxt):
  match res:
    case Result/Ok:
      nxt = undefer(nxt)
      return nxt(res.value)
    case Result/Err:
      return res
```

However, the second argument, `nxt`, is actually a deferred call to the continuation, passing any free variables as arguments.
Therefore, all `bind` functions must call the builtin function `undefer` before using the value of `nxt`, as in the example above.
This is necessary to ensure that the continuation in recursive monadic functions stays lazy and doesn't expand infinitely.

This is an example of a recursive function that would loop if passing the variable `a` to the recursive call `Result/foo(a, b)` was not deferred:

```python
def Result/foo(x, y):
  with Result:
    a <- Result/Ok(1)
    if b:
      b = Result/Err(x)
    else:
      b = Result/Ok(y)
    b <- b
    return Result/foo(a, b)
```

Other statements are allowed inside the `with` block and it can both return a value at the end and bind a variable, like branching statements do.

```python
# Also ok:
with Result:
  x <- safe_div(2, 0);
  y = x
return y
```

The name `wrap` is bound inside a `with` block as a shorthand for `Type/wrap`,
and it calls the unit function of the monad, also called `pure` in some languages:

```python
def Result/wrap(x):
  return Result/Ok(x)

with Result:
  x <- some_operation(...)
  y <- some_operation(...)
  return wrap(x * y)
```

### Def

Creates a local function visible in the current block capturing variables:

```python
def main:
  y = 41
  x = 1
  def aux_add(x):
    return x + y
  return aux_add(x)
```

## Expressions

### Variables

```python
some_var

foo/bar
```

A variable can be anything matching the regex `[A-Za-z0-9_.-/]+` but with some restrictions:

- It can not start with `//`
- It can not contain `__`

A variable is a name for some immutable expression. It is possible to rebind variables with the same name.

```python
x = 1
x = x + 1
```

Note that `-` is also used for negative numbers and as the numeric operator. Bend's grammar is greedily parsed from left to right, meaning that `x-3` always represents a name and not `x - 3` or a sequence of expressions like in `[x -3]`.

### Lambdas

```python
lambda x: x

lambda x, y: y

λx y: x
```

Lambdas represents anonymous inline functions, it can bind a variable and has an expression as body.

Using `,` is optional.

### Unscoped Lambdas and Variables

```python
lambda $x: $x

λ$x $y: $x
```

Like lambdas, with the exception that the variable starts with a `$` sign. Every unscoped variable in a function must have a unique name and must be used exactly once.

Unscoped variables are not transformed and linearized like normal scoped variables.

Read [using scopeless lambdas](/docs/using-scopeless-lambdas.md) to know more about their behavior.

### Function Call

```python
callee(arg_1, arg_2, arg_n)
```

A call is written with a callee followed by a list of arguments. Arguments can be optionally separated by `,`.

The effect of a function call is to substitute the callee with it's body and replace the arguments by the passed variables.

The called function can be any expression and it supports partial applications.

Optionally, if you call a function by its name, you can used named arguments:

```python
callee(expr1, expr2, arg4 = expr3, arg3 = expr4)
```

In case named arguments are used, they must come after the positional arguments and the function must be called with exactly the number of arguments of its definition.

### Eraser

```python
*

eraser = *

*(41 + 1)  # applies 41 + 1 to `*` erasing the number and returns `*`

* = 41 + 1 # erases 41 + 1
```

The effect of an eraser is to free memory. Erasers behave like a `null`.

It's impossible to compare or match eraser values.

It is implicitly inserted for variables that have not been used:

```python
def constant(x):
  return 8345
```

### Tuple

```python
(3, 9)
```

A Tuple is surrounded by `(` `)` and should contain 2 or more elements. Elements are separated by `,`.

### Superposition

```python
{1 2 3}
```

A superposition of values is defined using `{` `}` with at least 2 expressions inside. Elements can be optionally separated by `,`.

Read [sups and dups](./dups-and-sups.md) to know more.

### Numbers and Infix Operations

Currently, bend supports 3 types of numbers: floats, integers and unsigned integers. All of then are 24 bit sized.

```python
f24 = +88.012

i24 = -42

u24 = 42
```

Currently, the 3 number types cannot be mixed.

| Operation             | Syntax   | Supported Types  |
| --------------------- | -------- | ---------------- |
| Addition              | x + y    | int, float, uint |
| Subtraction           | x - y    | int, float, uint |
| Multiplication        | x \* y   | int, float, uint |
| Division              | x / y    | int, float, uint |
| Remainder             | x % y    | int, float, uint |
| Exponentiation        | x \*\* y | float            |
| Equal                 | x == y   | int, float, uint |
| Not Equal             | x != y   | int, float, uint |
| Less Than             | x < y    | int, float, uint |
| Greater Than          | x > y    | int, float, uint |
| Less Than or Equal    | x <= y   | int, float, uint |
| Greater Than or Equal | x >= y   | int, float, uint |
| Bitwise And           | x & y    | int, uint        |
| Bitwise Or            | x \| y   | int, uint        |
| Bitwise Xor           | x ^ y    | int, uint        |

Hexadecimal and binary floating-point literals are also supported.

In these representations, each digit after the point is divided according to the base’s power of the digit's position.
Specifically, for hexadecimal floating-point numbers, each place after the dot represents a fraction of 16 to the power of the digit's depth.
Similarly, for binary floating-point numbers, each place after the dot represents a fraction of 2 to the power of the digit's depth.

```python
0xA.A == 10.625

0b111.111 == 7.875
```

### Constructor Literals

Constructors are just functions.
A Constructor expression is equivalent to calling a Constructor function, they have 2 syntaxes:

```python
# Constructor syntax, requires all field names
Type/Ctr { field1: 4, field2: 8 }

# Function syntax
Type/Ctr(field1 = 4, field2 = 8)

Type/Ctr(4, field2 = 8)

Type/Ctr(4, 8)

Type/Ctr(4) # Can be partially applied if not using named arguments
```

### Character Literal

```python
'x'
```

A Character is surrounded with `'`. Accepts unicode characters, unicode escapes in the form '\u{hex value}' and is desugared to the unicode codepoint as an `u24`.

Only supports unicode codepoints up to `0xFFFFFF`.

### Symbol Literal

```python
# Becomes 2146 (33 << 6 + 34)
`hi`
```

A Symbol encodes a up to 4 base64 characters as a `u24` number. It is surrounded by `\``.

Empty characters are interpreted as `A` which has value 0, meaning that `B` is the same as `AAAB`.

### String Literal

```python
"Hello, World!"
```

A String literal is surrounded with `"`. Accepts the same values as characters literals.

It is desugared to constructor calls of the built-in type String, `String/cons(head, ~tail)` and `String/nil` .

### List Literal

```python
[1, 2, "three"]
```

A List literal is surrounded by `[` `]`. The elements must be separated by `,`.

It is desugared to constructor calls of the built-in type List, `List/cons(head, ~tail)` and `List/nil` .

### Tree Literals

```python
![![1, 2], ![3, 4]]
```

The Tree literals `![]` and `!` are used to create values of the built-in type `Tree`.

`![a b]` is equivalent to `Tree/Node(a, b)`.

`!x` is equivalent to `Tree/Leaf(x)`.

### Map Literals

```python
{ 0: 4, `hi`: "bye", 'c': 2 + 3 }
x[0] = 5     # Assigns the key 0 to the value 5
return x[0]  # Gets the value of the key 0
```

Bend has a built-in binary tree map data structure where the key is a `u24`, meaning you can use numbers, characters, and symbols as keys.

### List Comprehension

```python
[x + 1 for x in list]

[x + 1 for x in list if x > 2]
```

A List Comprehension generates a new list, it can be extracted in 3 parts.

`[expression . iterator . condition]`

Expression: The expression to be performed in the iterator element.

Iterator: Binds a name to the list elements.

Condition: Optional, is used to filter the list elements.

It is desugared to a fold statement:

```python
fold list:
  List/cons:
    if condition:
      List/cons(list.head, list.tail)
    else:
      list.tail
  List/nil:
    List/nil
```
</Content from syntax.md>

3. Data Types:
Built-in numeric types:
- u24: unsigned 24-bit integer
- i24: signed 24-bit integer
- f24: 24-bit float

<Content from native-numbers.md>
# Native numbers

Currently Bend supports 3 types of native numbers for fast numeric operations (compared to lambda-encoded numbers):

- U24: Unsigned integers (24 bits)
- I24: Signed integers (24 bits, two's complement)
- F24: Floating point numbers (single precision IEEE-754 floating point with the last bits of the mantissa implicitly set to zero)

### U24

Unsigned numbers are written as just the number and are represented as a 24 bit unsigned integer.

```rs
two = 2
```

### I24

Signed numbers are written with a `+` or `-` sign and are represented as a 24 bit two's complement integer.

```rs
minus_two = -2
plus_0 = +0
```

Positive numbers _must_ be written with a `+` sign, otherwise they'll be interpreted as unsigned.

Numbers can also be written in binary or hexadecimal form. Underscores can be optionally used as digit separators to make large numbers more readable.

````rs
decimal =     1194684
binary =      0b100_100_011_101_010_111_100
hexadecimal = 0x123_abc
hex_signed = -0xbeef


### F24

Floating point numbers must have the decimal point `.` and can optionally take a sign `+` or `-`.
They are represented as IEEE-754 single precision floating point numbers with the last bits of the mantissa implicitly set to zero.

```py
one = 1.0
pi = +3.1415926535897932384626433 # Will get rounded to 24bit float
a_millionth = 0.000001
zero = 0.0
minus_zero = -0.0
````

### Mixing number types

The three number types are fundamentally different.
If you mix two numbers of different types, HVM will interpret the binary representation of one of them incorrectly, leading to incorrect results. Which number is interpreted incorrectly depends on the situation and shouldn't be relied on for now.

At the HVM level, both type and the operation are stored inside the number nodes as tags. One number stores the type, the other the operation.
That means that we lose the type information of one of the numbers, which causes this behavior.
During runtime, the executed numeric function depends on both the type tag and the operation tag. For example, the same tag is used for unsigned bitwise and floating point atan2, so mixing number types can give you very unexpected results.

At the moment Bend doesn't have a way to convert between the different number types, but it will be added in the future.

### Operations

There is also support for native operations.
In "Imp" syntax they are infix operators and in "Fun" syntax they are written in reverse polish notation (like you'd call a normal function).
Each operation takes two arguments and returns a new number.

```rs
# In Fun syntax
some_val = (+ (+ 7 4) (* 2 3))
```

These are the currently available operations:

| Operation | Description              | Accepted types | Return type       |
| --------- | ------------------------ | -------------- | ----------------- |
| \+        | Addition                 | U24, I24, F24  | Same as arguments |
| \-        | Subtraction              | U24, I24, F24  | Same as arguments |
| \*        | Multiplication           | U24, I24, F24  | Same as arguments |
| \/        | Division                 | U24, I24, F24  | Same as arguments |
| \%        | Modulo                   | U24, I24, F24  | Same as arguments |
| \==       | Equality                 | U24, I24, F24  | U24               |
| \!=       | Inequality               | U24, I24, F24  | U24               |
| \<        | Less than                | U24, I24, F24  | U24               |
| \<=       | Less than or equal to    | U24, I24, F24  | U24               |
| \>        | Greater than             | U24, I24, F24  | U24               |
| \>=       | Greater than or equal to | U24, I24, F24  | U24               |
| \&        | Bitwise and              | U24, I24       | Same as arguments |
| \|        | Bitwise or               | U24, I24       | Same as arguments |
| \^        | Bitwise xor              | U24, I24       | Same as arguments |
| \*\*      | Exponentiation           | F24            | F24               |

### Functions

| Name           | Description                     | Accepted types | Return type |
| -------------- | ------------------------------- | -------------- | ----------- |
| `log(x, base)` | Logarithm                       | F24            | F24         |
| `atan2(x, y)`  | 2 arguments arctangent (atan2f) | F24            | F24         |
</Content from native-numbers.md>

Other built-in types:
<Content from builtins.md>
## String

```python
type String = (Cons head ~tail) | (Nil)
```

- **Nil**: Represents an empty string.
- **Cons head ~tail**: Represents a string with a `head` character and a `tail` string.

### Syntax

A String literal is surrounded with `"`. Accepts the same values as characters literals.

```
"Hello, World!"
```

### Functions

#### String/equals

Checks if two strings are equal.

```python
def String/equals(s1: String, s2: String) -> u24
```

#### String/split

Splits a string into a list of strings based on the given delimiter.

```python
def String/split(s: String, delimiter: u24) -> [String]
```

## List

```python
type List = (Cons head ~tail) | (Nil)
```

- **Nil**: Represents an empty list.
- **Cons head ~tail**: Represents a list with a `head` element and a `tail` list.

### Syntax

A List of values can be written using `[ ]`, it can have multiple values inside, using `,` you can divide its value in a list of multiple elements.

```
["This", "List", "Has", "Multiple", "Values"]
```

### Functions

#### List/length

```python
def List/length(list: [a]) -> (length: u24, list: [a])
```

Returns a tuple containing the length and the list itself.

#### List/reverse

```python
def List/reverse(list: [a]) -> [a]
```

Reverses the elements of a list.

#### List/flatten

```python
def List/flatten(list: [[a]]) -> [a]
```

Returns a flattened list from a list of lists. Example:

```python
List/flatten([[1], [2, 3], [4]])

# Result: [1, 2, 3, 4]
```

#### List/concat

```python
def List/concat(xs: [a], ys: [a]) -> [a]
```

Appends two lists together. Example:

```python
List/concat([1, 2], [4, 5])

# Result: [1, 2, 4, 5]
```

#### List/filter

Filters a list based on a predicate function.

```python
List/filter(xs: List(T), pred: T -> Bool) -> List(T)
```

#### List/split_once

Splits a list into two lists at the first occurrence of a value.

```python
List/split_once(xs: List(T), val: T) -> (Result(List(T), List(T)))
```

## Result

```python
type Result<A, B>:
  Ok { val: A }
  Err { val: B }
```

### Result/unwrap

Returns the inner value of `Result/Ok` or `Result/Err`.

If the types `A` and `B` are different, should only be used in type unsafe programs or when only one variant is guaranteed to happen.

```python
def Result/unwrap(result: Result<A, B>): A || B
```

## Tree

```python
type Tree:
  Node { ~left, ~right }
  Leaf { value }
```

**`Tree`** represents a tree with values stored in the leaves.
Trees are a structure that naturally lends itself to parallel recursion, so writing your problem in terms of trees is a good first approach to parallelize your code.

- **Node { ~left ~right }**: Represents a tree node with `left` and `right` subtrees.
- **Leaf { value }**: Represents one of the ends of the tree, storing `value`.

#### Syntax

**Bend** provides the `![]` operator to create tree branches and the `!` operator to create a tree leaf.

```py
# ![a, b] => Equivalent to Tree/Node { left: a, right: b }
# !x      => Equivalent to Tree/Leaf { value: x }
tree = ![![!1, !2],![!3, !4]]
```

Technically your trees don't need to end with leaves, but if you don't, your program will be very hard to reason about.

## Map

```python
type Map:
  Node { value ~left ~right }
  Leaf
```

**`Map`** represents a tree with values stored in the branches.
It is meant to be used as an efficient map data structure with integer keys and O(log n) read and write operations.

- **Node { value ~left ~right }**: Represents a map node with a `value` and `left` and `right` subtrees. Empty nodes have `*` stored in the `value` field.
- **Leaf**: Represents an unwritten, empty portion of the map.

#### Syntax

Here's how you create a new `Map` with some initial values.:

```python
{ 0: 4, `hi`: "bye", 'c': 2 + 3 }
```

The keys must be `U24` numbers, and can be given as literals or any other expression that evaluates to a `U24`.

The values can be anything, but storing data of different types in a `Map` will make it harder for you to reason about it.

You can read and write a value of a map with the `[]` operator:

```python
map = { 0: "zero", 1: "one", 2: "two", 3: "three" }
map[0] = "not zero"
map[1] = 2
map[2] = 3
map[3] = map[1] + map[map[1]]
```

Here, `map` must be the name of the `Map` variable, and the keys inside `[]` can be any expression that evaluates to a `U24`.

## Map functions

### Map/empty

Initializes an empty map.

```python
Map/empty = Map/Leaf
```

### Map/get

Retrieves a `value` from the `map` based on the `key`.
Returns a tuple with the value and the `map` unchanged.

```rust
Map/get map key =
  match map {
    Map/Leaf: (*, map)
    Map/Node:
      switch _ = (== 0 key) {
        0: switch _ = (% key 2) {
          0:
            let (got, rest) = (Map/get map.left (/ key 2))
            (got, (Map/Node map.value rest map.right))
          _:
            let (got, rest) = (Map/get map.right (/ key 2))
            (got, (Map/Node map.value map.left rest))
        }
        _: (map.value, map)
      }
  }
```

#### Syntax

Considering the following map

```python
{ 0: "hello", 1: "bye", 2: "maybe", 3: "yes"}
```

The `get` function can be written as

```
return x[0]  # Gets the value of the key 0
```

And the value resultant from the get function would be:

```
"hello"
```

### Map/set

Sets a `value` in the `map` at the specified `key`.
Returns the map with the new value.

```rust
Map/set map key value =
  match map {
    Map/Node:
      switch _ = (== 0 key) {
        0: switch _ = (% key 2) {
          0: (Map/Node map.value (Map/set map.left (/ key 2) value) map.right)
          _: (Map/Node map.value map.left (Map/set map.right (/ key 2) value))
        }
        _: (Map/Node value map.left map.right)
      }
    Map/Leaf:
      switch _ = (== 0 key) {
        0: switch _ = (% key 2) {
          0: (Map/Node * (Map/set Map/Leaf (/ key 2) value) Map/Leaf)
          _: (Map/Node * Map/Leaf (Map/set Map/Leaf (/ key 2) value))
        }
        _: (Map/Node value Map/Leaf Map/Leaf)
      }
  }
```

#### Syntax

Considering the following tree

```python
{ 0: "hello", 1: "bye", 2: "maybe", 3: "yes"}
```

The `set` function can be written as

```py
x[0] = "swapped"     # Assigns the key 0 to the value "swapped"
```

And the value resultant from the get function would be:

```py
{ 0: "swapped", 1: "bye", 2: "maybe", 3: "yes"}
```

If there's no matching `key` in the tree, it would add a new branch to that tree with the value `set`

```py
x[4] = "added"     # Assigns the key 4 to the value "added"
```

The new tree

```py
{ 0: "swapped", 1: "bye", 2: "maybe", 3: "yes", 4: "added"}
```

### Map/map

Applies a function to a value in the map.
Returns the map with the value mapped.

```rust
Map/map (Map/Leaf)                  key f = Map/Leaf
Map/map (Map/Node value left right) key f =
  switch _ = (== 0 key) {
    0: switch _ = (% key 2) {
      0:
        (Map/Node value (Map/map left (/ key 2) f) right)
      _:
        (Map/Node value left (Map/map right (/ key 2) f))
    }
    _: (Map/Node (f value) left right)
  }
```

#### Syntax

With the same map that we `set` in the previous section, we can map it's values with `@=`:

```py
x[0] @= lambda y: String/concat(y, " and mapped")
# x[0] now contains "swapped and mapped"
```

## Nat

```python
type Nat = (Succ ~pred) | (Zero)
```

- **Succ ~pred**: Represents a natural number successor.
- **Zero**: Represents the natural number zero.

### Syntax

A Natural Number can be written with literals with a `#` before the literal number.

```
#1337
```

## DiffList

DiffList is a list that has constant time prepends (cons), appends and concatenation, but can't be pattern matched.

It is implemented as a function that receives a list to be appended to the last element of the DiffList.

For example, the list `List/Cons(1, List/Cons(2, List/Nil))` can be written as the difference list `lambda x: List/Cons(1, List/Cons(2, x))`.

### Functions

#### DiffList/new

Creates a new difference list.

```python
def DiffList/new() -> (List(T) -> List(T))
```

#### DiffList/append

Appends a value to the end of the difference list.

```python
def DiffList/append(diff: List(T) -> List(T), val: T) -> (List(T) -> List(T))
```

#### DiffList/cons

Appends a value to the beginning of the difference list.

```python
def DiffList/cons(diff: List(T) -> List(T), val: T) -> (List(T) -> List(T))
```

#### DiffList/to_list

Converts a difference list to a regular cons list.

```python
def DiffList/to_list(diff: List(T) -> List(T)) -> (List(T))
```
</Content from builtins.md>

Note: The Tree type is particularly important for parallel computations in Bend.

4. Pattern Matching:
<Content from pattern-matching.md>
# Pattern Matching

Switches on many numbers are compiled to sequences of simple switch expressions:
```py
  # These two are equivalent
  switch n {
    0: A
    1: B
    2: C
    _: (D n-3)
  }

  switch n {
    0: A
    _: switch n-1 = n-1 {
      0: B
      _: switch n-2 = n-1-1 {
        0: C
        _: use n-3 = n-2-1; (D n-3)
      }
    }
  }
```

Matches on ADT constructors are compiled to different expressions depending on the chosen encoding:
```py
type Maybe = (Some val) | None

UnwrapOrZero x = match x {
  Some: x.val
  None: 0
}

# If the current encoding is 'adt-num-scott' it becomes:
Some = λval λx (x 0 val)
None = λx (x 1)
UnwrapOrZero x = (x λtag switch tag {
  0: λx.val x.val
  _: λ* 0
})

# Otherwise, if the current encoding is 'adt-scott' it becomes:
Some = λval λSome λNone (Some val)
None = λSome λNone None
UnwrapOrZero x = (x λx.val x.val 0)
```

### Pattern Matching functions

Besides `match`and `switch` terms, Bend also supports equational-style pattern matching functions.

```py
And True  b = b
And False * = False
```

There are advantages and disadvantages to using this syntax.
They offer more advanced pattern matching capabilities and also take care linearizing variables to make sure that recursive definitions work correctly in strict evaluation mode, but take away your control of how the pattern matching is implemented and can be a bit more resource intensive in some cases.

Pattern matching equations are transformed into a tree of `match` and `switch` terms from left to right.
```py
# These two are equivalent
(Foo 0 false (Cons h1 (Cons h2 t))) = (A h1 h2 t)
(Foo 0 * *) = B
(Foo n false *) = n
(Foo * true *) = 0

Foo = λarg1 λarg2 λarg3 (switch arg1 {
  0: λarg2 λarg3 match arg2 {
    true: λarg3 B
    false: λarg3 match arg3 {
      Cons: (match arg3.tail {
        Cons: λarg3.head (A arg3.head arg3.tail.head arg3.tail.tail)
        Nil: λarg3.head B
      } arg3.head)
      Nil: B
    }
  }
  _: λarg2 λarg3 (match arg2 {
    true: λarg1-1 0
    false: λarg1-1 (+ arg1-1 0)
  } arg1-1)
} arg2 arg3)
```
Besides the compilation of complex pattern matching into simple `match` and `switch` expressions, this example also shows how some arguments are pushed inside the match.
When compiling for strict evaluation, by default any variables that are used inside a match get linearized by adding a lambda in each arm and an application passing its value inwards.
To ensure that recursive pattern matching functions don't loop in strict mode, it's necessary to make the match arms combinators, so that they can be converted into separate functions and a lazy reference is used in the match arm.
```py
# This is what the Foo function actually compiles to.
# With -Olinearize-matches and -Ofloat-combinators (default on strict mode)
(Foo) = λa λb λc (switch a { 0: Foo$C5; _: Foo$C8 } b c)

(Foo$C5) = λd λe (d Foo$C0 Foo$C4 e) # Foo.case_0
(Foo$C0) = λ* B                      # Foo.case_0.case_true
(Foo$C4) = λg (g Foo$C3 B)           # Foo.case_0.case_false
(Foo$C3) = λh λi (i Foo$C1 Foo$C2 h) # Foo.case_0.case_false.case_cons
(Foo$C1) = λj λk λl (A l j k)        # Foo.case_0.case_false.case_cons.case_cons
(Foo$C2) = λ* B                      # Foo.case_0.case_false.case_cons.case_nil

(Foo$C8) = λn λo λ* (o Foo$C6 Foo$C7 n) # Foo.case_+
(Foo$C6) = λ* 0                         # Foo.case_+.case_true
(Foo$C7) = λr (+ r 1)                   # Foo.case_+.case_false
```

Pattern matching equations also support matching on non-consecutive numbers:
```rust
Parse '(' = Token.LParenthesis
Parse ')' = Token.RParenthesis
Parse 'λ' = Token.Lambda
Parse  n  = (Token.Name n)
```
This is compiled to a cascade of `switch` expressions, from smallest value to largest.
```py
Parse = λarg0 switch matched = (- arg0 '(') {
  0: Token.LParenthesis
  # ')' + 1 - '(' is resolved during compile time
  _: switch matched = (- matched-1 ( ')'-1-'(' ) {
    0: Token.RParenthesis
    _: switch matched = (- matched-1 ( 'λ'-1-')' ) {
      0: Token.Lambda
      _: use n = (+ 1 matched-1); (Token.Name n)
    }
  }
}
```
Unlike with `switch`, with pattern matching equations you can't access the value of the predecessor of the matched value directly, but instead you can match on a variable.
Notice how in the example above, `n` is bound to `(+ 1 matched-1)`.

Notice that this definition is valid, since `*` will cover both `p` and `0` cases when the first argument is `False`.

```rust
pred_if False * if_false = if_false
pred_if True  p *        = (- p 1)
pred_if True  0 *        = 0
```

Pattern matching on strings and lists desugars to a list of matches on List/String.cons and List/String.nil

```py
Hi "hi" = 1
Hi _ = 0

Foo [] = 0
Foo [x] = x
Foo _ = 3

# Becomes:
Hi (String.cons 'h' (String.cons 'i' String.nil)) = 2
Hi _ = 0

Foo List.nil = 0
Foo (List.cons x List.nil) = x
Foo _ = 3
```
</Content from pattern-matching.md>

5. Parallelism in Bend:
Bend automatically parallelizes independent operations. To leverage this:
- Use tree structures for computations when possible
- Avoid mutable state and traditional loops
- Utilize recursive patterns

Example of parallel computation:
```
# A very simple example of a massively parallel program
# Creates a tree with numbers and then sums all values in parallel

# a binary tree
type MyTree:
  Node { val, ~left, ~right }
  Leaf

# sums all values in a tree
def sum(tree):
  fold tree:
    case MyTree/Node:
      return tree.val + tree.left + tree.right
    case MyTree/Leaf:
      return 0

# generates a binary tree of given depth
def gen(depth):
  bend height=0, val = 1:
    when height < depth:
      tree = MyTree/Node { val: val, left: fork(height+1, 2*val), right: fork(height+1, 2*val+1) }
    else:
      tree = MyTree/Leaf
  return tree

# returns the sum of [1 .. 2^16), truncated to 24 bits
def main:
  return sum(gen(16))
```

6. Function Optimization:
Key points for optimizing recursive functions:
- Use supercombinator formulation to prevent infinite expansion
- Linearize matches and float combinators (compiler options, automatic in strict mode)
- Be cautious with mutual recursion

For more details, refer to the Lazy-definitions.md and compiler-options.md files, which are not included here.

7. Math:
<Content from builtins.md>
## Math

### Math/log

```py
def Math/log(x: f24, base: f24) -> f24
```

Computes the logarithm of `x` with the specified `base`.

### Math/atan2

```py
def Math/atan2(x: f24, y: f24) -> f24
```

Computes the arctangent of `y / x`.

Has the same behaviour as `atan2f` in the C math lib.

### Math/PI

Defines the Pi constant.

```py
def Math/PI: f24 = 3.1415926535
```

### Math/E

Euler's number

```py
def Math/E: f24 = 2.718281828
```

### Math/sin

Computes the sine of the given angle in radians.

```py
def Math/sin(a: f24) -> f24
```

### Math/cos

Computes the cosine of the given angle in radians.

```py
def Math/cos(a: f24) -> f24
```

### Math/tan

Computes the tangent of the given angle in radians.

```py
def Math/tan(a: f24) -> f24
```

### Math/cot

Computes the cotangent of the given angle in radians.

```py
def Math/cot(a: f24) -> f24
```

### Math/sec

Computes the secant of the given angle in radians.

```py
def Math/sec(a: f24) -> f24
```

### Math/csc

Computes the cosecant of the given angle in radians.

```py
def Math/csc(a: f24) -> f24
```

### Math/atan

Computes the arctangent of the given angle.

```py
def Math/atan(a: f24) -> f24
```

### Math/asin

Computes the arcsine of the given angle.

```py
def Math/asin(a: f24) -> f24
```

### Math/acos

Computes the arccosine of the given angle.

```py
def Math/acos(a: f24) -> f24
```

### Math/radians

Converts degrees to radians.

```py
def Math/radians(a: f24) -> f24
```

### Math/sqrt

Computes the square root of the given number.

```py
def Math/sqrt(n: f24) -> f24
```

### Math/ceil

Round float up to the nearest integer.

```py
def Math/ceil(n: f24) -> f24
```

### Math/floor

Round float down to the nearest integer.

```py
def Math/floor(n: f24) -> f24
```

### Math/round

Round float to the nearest integer.

```py
def Math/round(n: f24) -> f24
```

## Lazy thunks

You can force a function call to be evaluated lazily by wrapping it in a lazy thunk.
In Bend, this can be expressed as `lambda x: x(my_function, arg1, arg2, ...)`.

To evaluate the thunk, you can use the `undefer` function or apply `lambda x: x` to it.
</Content from builtins.md>

8. Basic I/O:
<Content from builtins.md>
## IO

The basic builtin IO functions are under development and will be stable in the next milestone.

Here is the current list of functions, but be aware that they may change in the near future.

### Printing

```python
def IO/print(text)
```

Prints the string `text` to the standard output, encoded with utf-8.

### Input

```python
def IO/input() -> String
```

Reads characters from the standard input until a newline is found.

Returns the read input as a String decoded with utf-8.

### File IO

#### File open

```python
def IO/FS/open(path, mode)
```

Opens a file with with `path` being given as a string and `mode` being a string with the mode to open the file in. The mode should be one of the following:

- `"r"`: Read mode
- `"w"`: Write mode (write at the beginning of the file, overwriting any existing content)
- `"a"`: Append mode (write at the end of the file)
- `"r+"`: Read and write mode
- `"w+"`: Read and write mode
- `"a+"`: Read and append mode

Returns an U24 with the file descriptor. File descriptors are not necessarily the same as the ones assigned by the operating system, but rather unique identifiers internal to Bend's runtime.

#### File descriptors for standard files

The standard input/output files are always open and assigned the following file descriptors:

- `IO/FS/STDIN = 0`: Standard input
- `IO/FS/STDOUT = 1`: Standard output
- `IO/FS/STDERR = 2`: Standard error

#### File close

```python
def IO/FS/close(file)
```

Closes the file with the given `file` descriptor.

#### File read

```python
def IO/FS/read(file, num_bytes)
```

Reads `num_bytes` bytes from the file with the given `file` descriptor.

Returns a list of U24 with each element representing a byte read from the file.

```python
def IO/FS/read_line(file)
```

Reads a line from the file with the given `file` descriptor.

Returns a list of U24 with each element representing a byte read from the file.

```python
def IO/FS/read_until_end(file)
```

Reads until the end of the file with the given `file` descriptor.

Returns a list of U24 with each element representing a byte read from the file.

```python
def IO/FS/read_file(path)
```

Reads an entire file with the given `path` and returns a list of U24 with each element representing a byte read from the file.

#### File write

```python
def IO/FS/write(file, bytes)
```

Writes `bytes`, a list of U24 with each element representing a byte, to the file with the given `file` descriptor.

Returns nothing (`*`).

```python
def IO/FS/write_file(path, bytes)
```

Writes `bytes`, a list of U24 with each element representing a byte, as the entire content of the file with the given `path`.

#### File seek

```python
def IO/FS/seek(file, offset, mode)
```

Moves the current position of the file with the given `file` descriptor to the given `offset`, an I24 or U24 number, in bytes.

`mode` can be one of the following:

- `IO/FS/SEEK_SET = 0`: Seek from start of file
- `IO/FS/SEEK_CUR = 1`: Seek from current position
- `IO/FS/SEEK_END = 2`: Seek from end of file

Returns nothing (`*`).

#### File flush

```python
def IO/FS/flush(file)
```

Flushes the file with the given `file` descriptor.

Returns nothing (`*`).

### Dinamically linked libraries

It's possible to dynamically load shared objects (libraries) with functions that implement the Bend IO interface.
You can read more on how to implement these libraries in the [Dynamically linked libraries and foreign functions](docs/ffi.md) documentation.

#### IO/DyLib/open

```py
def IO/DyLib/open(path: String, lazy: u24) -> u24
```

Loads a dynamic library file.

- `path` is the path to the library file.
- `lazy` is a boolean encoded as a `u24` that determines if all functions are loaded lazily (`1`) or upfront (`0`).
- Returns an unique id to the library object encoded as a `u24`.

#### IO/DyLib/call

```py
def IO/DyLib/call(dl: u24, fn: String, args: Any) -> Any
```

Calls a function of a previously opened library.

- `dl` is the id of the library object.
- `fn` is the name of the function in the library.
- `args` are the arguments to the function. The expected values depend on the called function.
- The returned value is determined by the called function.

#### IO/DyLib/close

```py
def IO/DyLib/close(dl: u24) -> None
```

Closes a previously open library.

- `dl` is the id of the library object.
- Returns nothing (`*`).

## Native number casting

### to_f24

```py
def to_f24(x: any number) -> f24
```

Casts any native number to an f24.

### to_u24

```py
def to_u24(x: any number) -> u24
```

Casts any native number to a u24.

### to_i24

```py
def to_i24(x: any number) -> i24
```

Casts any native number to an i24.

## String encoding / decoding

### String/decode_utf8

```py
def String/decode_utf8(bytes: [u24]) -> String
```

Decodes a sequence of bytes to a String using utf-8 encoding.

### String/decode_ascii

```py
def String/decode_ascii(bytes: [u24]) -> String
```

Decodes a sequence of bytes to a String using ascii encoding.

### String/encode_utf8

```py
def String/encode_utf8(s: String) -> [u24]
```

Encodes a String to a sequence of bytes using utf-8 encoding.

### String/encode_ascii

```py
def String/encode_ascii(s: String) -> [u24]
```

Encodes a String to a sequence of bytes using ascii encoding.

### Utf8/decode_character

```py
def Utf8/decode_character(bytes: [u24]) -> (rune: u24, rest: [u24])
```

Decodes a utf-8 character, returns a tuple containing the rune and the rest of the byte sequence.

### Utf8/REPLACEMENT_CHARACTER

```py
def Utf8/REPLACEMENT_CHARACTER: u24 = '\u{FFFD}'
```
</Content from builtins.md>

9. Examples:
Fibonacci (recursive and iterative):
```
# Program to calculate fibonacci numbers.

# Calculates fibonacci numbers recursively.
# Although branching recursion is usually a good idea to parallelize,
# it makes this code run in exponential time.
def fib_recursive(n):
  switch n:
    case 0:
      return 0
    case 1:
      return 1
    case _:
      return fib_recursive(n-2) + fib_recursive(n-2 + 1)

# Calculates fibonacci numbers iteratively (tail-recursively).
# This function is inherently sequential, but runs in linear time.
def fib_iterative(n):
  bend a=0, b=1, n:
    when n != 0:
      return fork(b, a + b, n - 1)
    else:
      return a

def main():
  # With the iterative version, we can calculate large fibonacci numbers
  # While with the recursive version, we will quickly run out of memory.
  # Note that for numbers larger than 36 the result will overflow the space of the 24-bit integer.
  # But we can run any number we want reasonably fast.
  return fib_iterative(30)

  # With the recursive version we create a tree with exponential size.
  # For numbers larger than ~45, this will hit the maximum HVM memory and crash.
  # Try uncommenting and running this line and compare the execution time.
  #return fib_recursive(20)
```

List operations:
```
### Singly-Linked List Type Definition: ###

# The List type is builtin, so we don't need to declare it.
# But this is how it's defined in the builtins file.
# type List:
#   Nil
#   Cons { head, ~tail }

###########################################

# List clear:
# List l -> list l
# clears all elements from list l. This is equivalent to initializing an empty list.
clear = @l []

# List concat:
# List l -> List l
# combines two lists (l1, l2) from left to right.
concat = @l1 @l2
  match l1 {
    List/Cons: (List/Cons l1.head (concat l1.tail l2))
    List/Nil: l2
  }

# List add_front:
# List l -> List l
# adds a non-List element e to the front of list l.
add_front = @l @e
  match l {
    List/Cons: (List/Cons e l)
    List/Nil: (List/Cons e List/Nil)
  }

# List append (add_back):
# List l -> List l
# adds a non-list element e to the back of list l.
append = @l @e
  (concat l (List/Cons e List/Nil))

# list sum:
# List l -> uint
# returns the sum of all items in the list.
sum = @l
  match l {
    List/Cons: (+ l.head (sum l.tail))
    List/Nil: 0
  }

# List reverse:
# List l -> List l
# reverses the order of elements in list l.
reverse.aux = @acc @l
  match l {
    List/Nil: acc
    List/Cons: (reverse.aux (List/Cons l.head acc) l.tail)
  }
reverse = @l
  (reverse.aux [] l)

# List length:
# List l -> uint
# returns the number of elements in list l.
len = @l
  match l {
    List/Nil: 0
    List/Cons: (+ 1 (len l.tail))
  }

# List count:
# List l -> uint -> uint
# returns the number of instances of Some s in list l.
count.aux = @acc @l @s
  match l {
    List/Nil: acc
    List/Cons: use acc = switch (== l.head s) {
      0: acc;
      _: (+ acc 1);
    }
    (count.aux acc l.tail s)
  }
count = @l @s
  (count.aux 0 l s)

# List index:
# List l -> Some s
# returns the value of a specific list index i, or * if the index doesn't exist.
index = @l @i
  match l {
    List/Cons:
      switch i {
        0: l.head
        _: (index l.tail (i-1))
      }
    List/Nil: *
  }

# List head:
# List l -> Some s
# returns the first item in the list, or [] if the list is empty.
head = @l
  match l {
    List/Cons: l.head
    List/Nil: []
  }

# List tail:
# List l -> List
# returns the list except for the first item in it, or [] if the list is empty.
def tail(l):
  match l:
    case List/Cons:
      return l.tail
    case List/Nil:
      return []

# List equals:
# List xs, List ys, function cmp -> 1|0
# Compares the elements in two lists and returns 1 if they're equal, and 0 otherwise.
# The function cmp compares two values and returns 1 if they're equal, and 0 otherwise.
equals xs ys cmp = match xs {
  List/Cons: match ys {
    List/Cons: if (cmp xs.head ys.head) {
      (equals xs.tail ys.tail cmp)
    } else {
      0
    }
    List/Nil: 0
  }
  List/Nil: match ys {
    List/Cons: 0
    List/Nil: 1
  }
}

# List pop_front:
# List l -> List l
# removes and discards the first item of list l.
# The new list is returned, or [] if the list is empty.
pop_front = @l
  match l {
    List/Cons: l.tail
    List/Nil: []
  }

# List pop_back:
# List l -> List l
# removes and discards the the last item of list l.
pop_back (List/Nil) = List/Nil
pop_back (List/Cons x List/Nil) = List/Nil
pop_back (List/Cons head tail) = (List/Cons head (pop_back tail))

# List remove:
# List l -> Some s -> List l
# removes the first occurrence of element e from list l.
remove = @l @s
  match l {
    List/Cons:
      switch (== l.head s) {
        0: (List/Cons l.head (remove l.tail s))
        _: l.tail
      }
    List/Nil: List/Nil
  }

# List split:
# list l -> uint i -> (List l, list l)
# splits list l into two lists (l1, l2) at index i.
# the second list takes the element at index i during the split.
split = @l @i (split.aux [] l i)

split.aux = @acc @l @i
  match l {
    List/Cons:
      switch i {
        0: (acc, l)
        _: (split.aux (append acc l.head) l.tail i-1)
      }
    List/Nil: *
  }


#################################

def main:
  return head([5, 4, 3, 2, 1])
#  return sum([1, 2, 3])
#  return split([1, 2, 3, 4, 5, 6, 7], 3)
#  return remove([1, 2, 1, 3], 1)
#  return pop_back([1, 2, 3, 4])
#  return pop_front([1, 2, 3])
#  return index([5, 3, 6, 8, 2], 0)
#  return clear([0, 2, 3])
#  return count([1, 2, 3, 3, 3, 4, 4, 5, 3, 1000], 4)
#  return len([1, 2, 3, 4, 4, 4])
#  return reverse([1, 2, 3, 4, 5])
#  return append([1, 2], 3)
#  return add_front([2, 3], 1)
#  return concat([1, 2], [3, 4])
```

Programming Guidelines:
- Prioritize immutable data structures and recursive patterns
- Leverage tree structures for parallel computations when possible
- Avoid mutable state and traditional loops
- Use pattern matching for control flow
- Think in terms of data transformations rather than step-by-step procedures
- Utilize `fold` and `bend` for working with recursive structures

Notes/Errata:
1. Type Hinting: The documentation should clearly state that type hinting is not supported in function definitions or within type definitions.
2. Constants: It should be explicitly mentioned that constants need to be defined as functions, e.g., `def AND(): return 0` instead of `def AND: u24 = 0`.
3. Switch/Case Statements: The documentation should clarify that switch/case statements can only use native numbers, not constants or enums.
4. Pattern Matching: It should be emphasized that when using `match` on a type, all possibilities must be enumerated.
5. Case Statements: The documentation should state that case statements cannot be inline and each case must have its own return statement.
6. If Statements: It should be noted that inline if statements are not supported.
7. IO Operations: The documentation needs to provide more detailed information on how IO operations are handled, particularly:
   - How to properly structure IO operations within a `with IO:` context.
   - The requirement for a return statement within the `with IO:` block.
   - How to force evaluation of IO operations, including more details on the use of `undefer`.
8. Equality Comparisons: It should be clarified that the equality operator (`==`) is only defined for native number types, and pattern matching should be used for other types.
9. Function Calls: The documentation should mention that all function calls must either receive their return value or discard it with `*`.
10. Lazy Evaluation: More information should be provided on Bend's lazy evaluation strategy and how it affects IO operations and other side effects.

*****************************
End of Bend Language Reference Guide
*****************************
